process_IP_datagram(us,header,data,srcMac)

Descripción: 
Esta función procesa datagramas IP recibidos. Se ejecuta una vez por cada trama Ethernet recibida con Ethertype 0x0800
Esta función debe realizar, al menos, las siguientes tareas:
Extraer los campos de la cabecera IP (incluida la longitud de la cabecera)
Calcular el checksum sobre la cabecera y comprobar que el valor es correcto
"Loggear" (usando logging.debug) el valor de los siguientes campos:
Longitud de la cabecera IP (multiplicada por 4)
ToS
IPID
Valor de las banderas DF y MF
Valor decimal de offset (multiplicado por 8)
TTL
Protocolo
IP origen y destino en notación decimal (a.b.c.d)
Analizar el valor del offset. Si el offset tiene un valor != 0 dejar de procesar el datagrama (pues no vamos a reensamblar).
Si el offset vale 0, comprobar si tenemos registrada una función de callback de nivel superior consultando el diccionario protocols y usando como clave el valor del campo protocolo del datagrama IP.
En caso de que haya una función de nivel superior registrada, debe llamarse a dicha función pasando los datos (payload) contenidos en el datagrama IP.
Tenga en cuenta que aunque el offset valga 0, puede ocurrir que MF=1. En ese caso estaremos pasando el primer fragmento al nivel superior, por lo que se podrá leer la cabecera del protocolo, pero no todo el contenido del mensaje ICMP o datagrama UDP.
 
Argumentos:
us: Datos de usuario pasados desde la llamada de pcap_loop. En nuestro caso será None
header: cabecera pcap_pkthdr
data: array de bytes con el contenido del datagrama IP
srcMac: MAC origen de la trama Ethernet que se ha recibido
Retorno: 
Ninguno
registerIPProtocol(callback,protocol)

Descripción: 
Esta función recibirá el nombre de una función y su valor de protocolo IP asociado y añadirá en la tabla (diccionario) de protocolos de nivel superior dicha asociación.
Este mecanismo nos permite saber a qué función de nivel superior debemos llamar al recibir un datagrama IP con un determinado valor del campo protocolo (por ejemplo TCP o UDP). Por ejemplo, podemos registrar una función llamada process_UDP_datagram asociada al valor de protocolo 17 y otra llamada process_ICMP_message asociada al valor de protocolo 1.
Argumentos:
callback: función de callback a ejecutar cuando se reciba un datagrama con el protocolo especificado como segundo argumento. La función que se pase como argumento debe tener el siguiente prototipo: funcion(us,header,data,srcIp):
us: son los datos de usuario pasados por pcap_loop (en nuestro caso este valor será siempre None
header: estructura pcap_pkthdr que contiene los campos len, caplen y ts.
data: payload del datagrama IP. Es decir, la cabecera IP NUNCA se pasa hacia arriba.
srcIP: dirección IP que ha enviado el datagrama actual.
Dónde:
La función no retornará nada. Si un datagrama se quiere descartar basta con hacer un return sin valor y dejará de procesarse.
protocol: valor del campo protocolo de IP para el cuál se quiere registrar una función de callback.
Retorno: 
Ninguno
 
initIP(interface,opts=None)
 
Descripción: 
Esta función inicializará el nivel IP. Esta función debe realizar, al menos, las siguientes tareas:
Llamar a initARP para inicializar el nivel ARP realizado en la práctica anterior.
Obtener (llamando a las funciones correspondientes) y almacenar en variables globales los siguientes datos:
IP propia
MTU
Máscara de red (netmask)
Gateway por defecto
Almacenar el valor de opts en la variable global ipOpts
Registrar a nivel Ethernet (llamando a registerCallback) la función process_IP_datagram con el Ethertype 0x0800
Inicializar el valor de IPID según lo indicado más arriba.
Argumentos:
interface: cadena de texto con el nombre de la interfaz sobre la que inicializar IP
opts: array de bytes con las opciones a nivel IP a incluir en los datagramas o None si no hay opciones a añadir
Retorno: 
True o False en función de si se ha inicializado el nivel o no.
sendIPDatagram(dstIP,data,protocol)

Descripción: 
Esta función construye un datagrama IP y lo envía. En caso de que los datos a enviar sean muy grandes la función debe generar y enviar el número de fragmentos IP que sean necesarios.
Esta función debe realizar, al menos, las siguientes tareas:
Determinar si se debe fragmentar o no y calcular el número de fragmentos a generar
Para cada datagrama o fragmento:
Construir la cabecera IP con los valores que corresponda. Incluir opciones en caso de que ipOpts sea distinto de None
Calcular el checksum sobre la cabecera y añadirlo
Añadir los datos recibidos a la cabecera IP
En el caso de que sea un fragmento ajustar los valores de los campos MF y offset de manera adecuada
Enviar el datagrama o fragmento llamando a sendEthernetFrame. Para determinar la dirección MAC de destino al enviar los datagramas usaremos la máscara de red y las IPs.
Una vez enviado el datagrama o los fragmentos:
Incrementar la variable IPID en 1.
Argumentos:
dstIP: entero de 32 bits con la IP destino del datagrama
data: array de bytes con los datos a incluir como payload en el datagrama
protocol: valor numérico del campo IP protocolo que indica el protocolo de nivel superior de los datos contenidos en el payload. Por ejemplo 1, 6 o 17.
Retorno: 
True o False en función de si se ha enviado el datagrama correctamente o no